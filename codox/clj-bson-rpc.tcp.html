<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clj-bson-rpc.tcp documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Clj-bson-rpc</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clj-bson-rpc</span></div></div></li><li class="depth-2 current"><a href="clj-bson-rpc.tcp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tcp</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-async-request.21"><div class="inner"><span>async-request!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-async-request-with-timeout.21"><div class="inner"><span>async-request-with-timeout!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-close.21"><div class="inner"><span>close!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-close-connection.21"><div class="inner"><span>close-connection!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-close-connection-and-server.21"><div class="inner"><span>close-connection-and-server!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-close-server.21"><div class="inner"><span>close-server!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-connect-rpc.21"><div class="inner"><span>connect-rpc!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-default-options"><div class="inner"><span>default-options</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-notify.21"><div class="inner"><span>notify!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-request.21"><div class="inner"><span>request!</span></div></a></li><li class="depth-1"><a href="clj-bson-rpc.tcp.html#var-request-with-timeout.21"><div class="inner"><span>request-with-timeout!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clj-bson-rpc.tcp</h1><div class="doc"><div class="markdown"><p>BSON-RPC Connection over <a href="https://github.com/ztellman/manifold">manifold</a> duplex stream.</p>
<p>Practical applications include using <a href="https://github.com/ztellman/aleph">aleph</a> to establish TCP connection (+ TLS) between the client and the server.</p>
<p>After an RPC connection has been set on both sides, the RPC nodes are principally equal. The TCP client may provide services which the TCP server then uses and vice versa.</p></div></div><div class="public anchor" id="var-async-request.21"><h3>async-request!</h3><div class="usage"><code>(async-request! rpc-ctx method &amp; params)</code></div><div class="doc"><div class="markdown"><p>RPC Request in a <code>clojure.core.async</code> go-block.</p>
<ul>
  <li><code>rpc-ctx</code> - The Context from <code>connect-rpc!</code>.</li>
  <li><code>method</code> - Remote method name - a keyword or string.</li>
  <li><code>params</code> - Parameters for the remote method.</li>
</ul>
<p>Returns a channel which will receive:</p>
<ul>
  <li>The Result message from the RPC Peer Node or</li>
  <li><code>:closed</code> or</li>
  <li><code>:send-failure</code></li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L354">view source</a></div></div><div class="public anchor" id="var-async-request-with-timeout.21"><h3>async-request-with-timeout!</h3><div class="usage"><code>(async-request-with-timeout! rpc-ctx timeout method &amp; params)</code></div><div class="doc"><div class="markdown"><p>RPC Request in a <code>clojure.core.async</code> go-block.</p>
<ul>
  <li><code>timeout</code> - Milliseconds to wait for remote method return value.</li>
  <li>Otherwise identical to <code>async-request!</code></li>
</ul>
<p>Returns a channel which will receive results identical to <code>async-request!</code> or possibly the value <code>:timeout</code> if waiting of result timed out.</p></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L387">view source</a></div></div><div class="public anchor" id="var-close.21"><h3>close!</h3><div class="usage"><code>(close! rpc-ctx)</code></div><div class="doc"><div class="markdown"><p>Utility for closing the connection from outside of request handler. Use <code>close-connection!</code> within response handler.</p></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L456">view source</a></div></div><div class="public anchor" id="var-close-connection.21"><h3>close-connection!</h3><div class="usage"><code>(close-connection!)</code><code>(close-connection! response)</code></div><div class="doc"><div class="markdown"><p>Call this function within your request or notification handler in order to disconnect current tcp connection. <code>close-connection!</code> does not return.</p>
<ul>
  <li><code>response</code> - Response sent to a request (if within a request handler)  just before disconnection. Defaults to nil if not provided.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L214">view source</a></div></div><div class="public anchor" id="var-close-connection-and-server.21"><h3>close-connection-and-server!</h3><div class="usage"><code>(close-connection-and-server!)</code><code>(close-connection-and-server! response)</code></div><div class="doc"><div class="markdown"><p>Call this function within your request or notification handler in order to close both current connection and the server socket. <code>close-connection-and-server!</code> does not return.</p>
<ul>
  <li><code>response</code> - Response sent to a request (if within a request handler)  just before disconnection. Defaults to nil if not provided.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L237">view source</a></div></div><div class="public anchor" id="var-close-server.21"><h3>close-server!</h3><div class="usage"><code>(close-server!)</code><code>(close-server! response)</code></div><div class="doc"><div class="markdown"><p>Call this function within your request or notification handler in order to close server socket. Does not disconnect your current connection. <code>close-server!</code> does not return.</p>
<ul>
  <li><code>response</code> - Response sent to a request (if within a request handler).  Defaults to nil if not provided.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L225">view source</a></div></div><div class="public anchor" id="var-connect-rpc.21"><h3>connect-rpc!</h3><div class="usage"><code>(connect-rpc! s)</code><code>(connect-rpc! s options)</code><code>(connect-rpc! s request-handlers notification-handlers)</code><code>(connect-rpc! s request-handlers notification-handlers options)</code></div><div class="doc"><div class="markdown"><p>Connect rpc services and create a context for sending bson-rpc requests and notifications to the rpc peer node over TCP connection.</p>
<ul>
  <li><code>s</code> - Manifold duplex stream connected to the rpc peer node.  (e.g. from aleph.tcp/start-server to the handler or from aleph.tcp/client)</li>
  <li><code>request-handlers</code>
    <ul>
      <li>A Map of request handlers: {::String/Keyword ::Function}. These functions are  exposed to be callable by the rpc peer node. Function return values  are sent back to peer node and any thrown errors are sent as error responses  to the peer node.</li>
      <li>Alternatively this parameter accepts a function which takes <code>rpc-ctx</code> and returns  an above-mentioned Map of request handlers. Necessary if any request handler needs  to send notifications to peer during the processing of request.  example function:
        <pre><code>(defn generate-request-handlers [rpc-ctx]
  {:quick-task quick-task
   :long-process (partial long-process rpc-ctx)})
</code></pre>
        <p>where the <code>long-process</code> will thus have the <code>rpc-ctx</code> and will be able to call  <code>(notify! rpc-ctx :report-progress details)</code> or even <code>(request! rpc-ctx ...)</code></p>
      </li>
    </ul>
  </li>
  <li><code>notification-handlers</code>
    <ul>
      <li>A Map of notification handlers: {::String/Keyword ::Function}. These functions  will receive the named notifications sent by the peer node.  Any errors thrown by these handlers will be delegated to a callback  defined by <code>(:notification-error-handler options)</code></li>
      <li>Alternatively can be a function which takes <code>rpc-ctx</code> and returns a Map of handlers.</li>
    </ul>
  </li>
  <li><code>options</code> - A Map of optional arguments. <code>default-options</code> are used as a baseline of which  any or all values can be overridden with ones provided by <code>options</code>.</li>
</ul>
<p>Valid keys for <code>options</code>:</p>
<ul>
  <li><code>:async-notification-handling</code> - Boolean for async handling of notifications.
    <ul>
      <li>false -&gt; Handler functions are guaranteed to be called in the message  receiving order. Next incoming message can&rsquo;t be processed until  the handler function returns.</li>
      <li>true -&gt; Handlers executed in go-blocks -&gt; random order.</li>
    </ul>
  </li>
  <li><code>:async-request-handling</code> - Boolean for async handling of requests. Async handling allows multiple  requests to processed in parallel (if client so wishes). Note that client  can enforce synchronous processing simply by waiting the answer to previous  request before calling new request.
    <ul>
      <li>Dispatching of responses is synchronous regardless of this setting.  If <code>:async-notification-handling</code> was set to <code>false</code> then all notifications  possibly sent by a (peer node) response handler will be processed by  the time the response is returned.</li>
    </ul>
  </li>
  <li><code>:bson-max-len</code> - Incoming bson message max length.</li>
  <li><code>:connection-closed-handler</code> - Is called when peer closes the connection.  One argument: <code>rpc-ctx</code>. Return value ignored.</li>
  <li><code>:connection-id</code> - ID to use in server logging to identify current connection.</li>
  <li><code>:id-generator</code> - Is called when a new ID for outgoing rpc request is needed. No arguments.  Must return a string or integer which should be unique over the duration of the connection.</li>
  <li><code>:idle-timeout</code> - Timeout in milliseconds. <code>idle-timeout-handler</code> will be triggered if timeout  is enabled and nothing has been received from peer node within <code>idle-timeout</code>.  Disable by setting to <code>nil</code>.</li>
  <li><code>:idle-timeout-handler</code> - One argument: <code>rpc-ctx</code>. Return value ignored.</li>
  <li><code>:invalid-id-response-handler</code> - Two arguments: <code>rpc-ctx</code> and message. Return value ignored.  Used if peer sends a response in which ID does not match with  any sent requests waiting for a response.</li>
  <li><code>:nil-id-error-handler</code> - Is called when an error response with <code>id: null</code> is received from the peer node.  (Normal error responses are marshalled to throw errors within request! calls.)  Two arguments: <code>rpc-ctx</code> and <code>message</code> (::String). Return value ignored.</li>
  <li><code>:notification-error-handler</code> - Two arguments: <code>rpc-ctx</code> and thrown Exception object. Return value ignored.</li>
  <li><code>:protocol-keyword</code> - Affects the name of the keyword used in bson message documents.  (e.g. using :jsonrpc would follow more closely the json rpc 2.0 specification)  Used protocol is still bson regardless of this keyword.</li>
  <li><code>:server</code> - A java.io.Closeable object. Give if your handlers need the ability to close the  server object.</li>
</ul>
<p>Returns <code>rpc-ctx</code> to be used with <code>request!</code> and <code>notify!</code>.</p></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L249">view source</a></div></div><div class="public anchor" id="var-default-options"><h3>default-options</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Default options. See <code>connect-rpc!</code> for semantic explanations. Use these values for keys which were not provided in the <code>options</code> argument.</p>
<p>Defaults:</p>
<ul>
  <li><code>:async-notification-handling</code> - Default value is <code>false</code>, which is based on an assumption  that typically notifications are order-sensitive messages e.g.  progress reports which must be handled in the exact order in which  they are received.</li>
  <li><code>:async-request-handling</code> - Default value is <code>true</code>. Async handling allows handlers to execute even  the most time-consuming tasks without blocking other incoming messages.  Yet the client side can deside whether to call requests in tight  sequential order or to call them in parallel.</li>
  <li><code>:bson-max-len</code> - The max capacity defined in bson specification: 2 147 483 647 bytes (Max Int32)</li>
  <li><code>:connection-closed-handler</code> - Default handler stops the service for the current stream and  closes the stream. (No effect on the server socket/object.)</li>
  <li><code>:connection-id</code> - Arbitrary unique ID to identify connection, shown in logging so that  multiple connections with separate clients can be traced. nil -&gt; generated integer id.</li>
  <li><code>:id-generator</code> - Default generator generates &lsquo;id-1&rsquo;, &lsquo;id-2&rsquo;, etc. ids for outbound requests.</li>
  <li><code>:idle-timeout</code> - Default value <code>nil</code> disables idle timeouts.</li>
  <li><code>:idle-timeout-handler</code> - Default handler stops the service for the current stream and  closes the stream. (No effect on the the server socket/object.)</li>
  <li><code>:invalid-id-response-handler</code> - Default handler logs the error.</li>
  <li><code>:nil-id-error-handler</code> - Default handler logs the error message sent by rpc peer node.</li>
  <li><code>:notification-error-handler</code> - Default handler logs the error.</li>
  <li><code>:protocol-keyword</code> - Default value <code>:bsonrpc</code></li>
  <li><code>:server</code> - Default value <code>nil</code></li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L171">view source</a></div></div><div class="public anchor" id="var-notify.21"><h3>notify!</h3><div class="usage"><code>(notify! rpc-ctx method &amp; params)</code></div><div class="doc"><div class="markdown"><p>Send RPC Notification to peer. Return boolean success value.</p>
<ul>
  <li><code>rpc-ctx</code> - Context returned by <code>connect-rpc!</code></li>
  <li><code>method</code> - Remote notification handler name - a keyword or string.</li>
  <li><code>params</code> - Parameters for the notification handler.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L443">view source</a></div></div><div class="public anchor" id="var-request.21"><h3>request!</h3><div class="usage"><code>(request! rpc-ctx method &amp; params)</code></div><div class="doc"><div class="markdown"><p>RPC Request to the peer node. Waits for a response indefinitely.</p>
<ul>
  <li><code>rpc-ctx</code> - Context returned by <code>connect-rpc!</code>.</li>
  <li><code>method</code> - Remote method name - a keyword or string.</li>
  <li><code>params</code> - Parameters for the remote method.</li>
</ul>
<p>Returns: The return value from the remote method or Throws:</p>
<ul>
  <li>clojure.lang.ExceptionInfo with <code>ex-data</code> mappings:
    <ul>
      <li>{:type :rpc-peer :code <rpc-error-code> :details <details-from-peer>} on peer node errors.</li>
      <li>{:type :rpc-connection-closed} If either this node or peer node closed the connection.</li>
      <li>{:type :rpc-buffer-overflow} Send buffer full.</li>
    </ul>
  </li>
</ul></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L399">view source</a></div></div><div class="public anchor" id="var-request-with-timeout.21"><h3>request-with-timeout!</h3><div class="usage"><code>(request-with-timeout! rpc-ctx timeout method &amp; params)</code></div><div class="doc"><div class="markdown"><p>RPC Request to the peer node. Waits for the response for up to the timeout length of time.</p>
<ul>
  <li><code>timeout</code> - Milliseconds to wait for remote method return value.</li>
  <li>Otherwise identical to <code>request!</code></li>
</ul>
<p>Returns: The return value from the remote method or Throws: Identically to <code>request!</code> or {:type :rpc-response-timeout} when timeouted.</p></div></div><div class="src-link"><a href="https://github.com/seprich/clj-bson-rpc/blob/master/src/clj_bson_rpc/tcp.clj#L430">view source</a></div></div></div></body></html>